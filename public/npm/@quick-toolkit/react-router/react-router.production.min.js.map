{"version":3,"file":"react-router.production.min.js","sources":["../../../packages/react-router/lib/context.ts","../../../packages/react-router/lib/router.ts","../../../packages/react-router/lib/hooks.tsx","../../../packages/react-router/lib/components.tsx","../../../packages/react-router/lib/constants.ts"],"sourcesContent":["import * as React from \"react\";\nimport type { History, Location } from \"history\";\nimport { Action as NavigationType } from \"history\";\n\nimport type {RouteMatch, RouteObject} from \"./router\";\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nexport const NavigationContext = React.createContext<NavigationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nexport const LocationContext = React.createContext<LocationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\nexport interface RouteContextObject {\n  outlet: React.ReactElement | null;\n  current: RouteObject | null;\n  matches: RouteMatch[];\n  routes: RouteObject[];\n  data: object | null;\n}\n\nexport const RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n  routes: [],\n  current: null,\n  data: null,\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n","import type { Location, Path, To } from \"history\";\nimport { parsePath } from \"history\";\nimport {LocaleLanguageKey} from \"./constants\";\nimport * as React from \"react\";\n\nexport function invariant(cond: any, message: string): asserts cond {\n  if (!cond) throw new Error(message);\n}\n\nexport function warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\nexport function warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport interface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  icon?: React.ReactNode;\n  element?: React.ReactNode;\n  validator?: (match: RouteMatch) => boolean;\n  title?: string | Record<LocaleLanguageKey, string>;\n  name?: string;\n  index?: boolean;\n  path?: string;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/generate-path\n */\nexport function generatePath(path: string, params: Params = {}): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/*\\*$/, (_) =>\n      params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\")\n    );\n}\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface RouteMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObject;\n  /**\n   * transform data\n   */\n  data: object | null;\n  /**\n   * The path query strings\n   */\n  search: string;\n  /**\n   * The path has strings\n   */\n  hash: string;\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-routes\n */\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): RouteMatch[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname, location);\n  }\n\n  return matches;\n}\n\ninterface RouteMeta {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObject;\n}\n\ninterface RouteBranch {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta[];\n}\n\nfunction flattenRoutes(\n  routes: RouteObject[],\n  branches: RouteBranch[] = [],\n  parentsMeta: RouteMeta[] = [],\n  parentPath = \"\"\n): RouteBranch[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<ParamKey extends string = string>(\n  branch: RouteBranch,\n  pathname: string,\n  path: Partial<Path>\n): RouteMatch<ParamKey>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: RouteMatch[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n\n    const iRouteMatch: RouteMatch = {\n      params: matchedParams,\n      search: path.search || \"\",\n      hash: path.hash || \"\",\n      data: null,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route: meta.route,\n    };\n\n    if (typeof meta.route.validator === \"function\" && !meta.route.validator(iRouteMatch)) return null;\n\n    matches.push(iRouteMatch);\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname;\n\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  let from: string;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original to value had one.\n  if (\n    toPathname &&\n    toPathname !== \"/\" &&\n    toPathname.endsWith(\"/\") &&\n    !path.pathname.endsWith(\"/\")\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\n\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\nconst normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n","import * as React from \"react\";\nimport type { Location, Path, To } from \"history\";\nimport { Action as NavigationType, parsePath } from \"history\";\n\nimport {LocationContext, NavigationContext, RouteContext, RouteContextObject} from \"./context\";\nimport type {\n  ParamParseKey,\n  Params,\n  PathMatch,\n  PathPattern,\n  RouteMatch,\n  RouteObject,\n} from \"./router\";\nimport {\n  getToPathname,\n  invariant,\n  joinPaths,\n  matchPath,\n  matchRoutes,\n  resolveTo,\n  warning,\n  warningOnce,\n} from \"./router\";\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-href\n */\nexport function useHref(to: To): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to);\n\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname =\n      pathname === \"/\"\n        ? basename + (endsWithSlash ? \"/\" : \"\")\n        : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-in-router-context\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-location\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigation-type\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-match\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet-context\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\nexport function useRouteContext(): RouteContextObject {\n  return React.useContext(RouteContext);\n}\n\nexport function useRouteCurrent(): RouteObject | null {\n  return React.useContext(RouteContext).current\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-params\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\nexport function useResolvedPath(to: To): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-routes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, { pathname: remainingPathname, search: location.search, hash: location.hash });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  return _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        })\n      ),\n    parentMatches,\n    routes,\n  );\n}\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = [],\n  routes: RouteObject[] = [],\n): React.ReactElement | null {\n  if (matches == null) return null;\n\n  return matches.reduceRight((outlet, match, index) => {\n    return (\n      <RouteContext.Provider\n        children={\n          match.route.element !== undefined ? match.route.element : outlet\n        }\n        value={{\n          outlet,\n          routes,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n          current: match.route,\n          data: match.data,\n        }}\n      />\n    );\n  }, null as React.ReactElement | null);\n}\n","import * as React from \"react\";\nimport type { InitialEntry, Location, MemoryHistory, Path, To } from \"history\";\nimport {\n  Action as NavigationType,\n  createMemoryHistory,\n  parsePath,\n} from \"history\";\n\nimport { LocationContext, NavigationContext, Navigator } from \"./context\";\nimport {\n  useInRouterContext,\n  useNavigate,\n  useOutlet,\n  useRoutes,\n  _renderMatches,\n} from \"./hooks\";\nimport type { RouteMatch, RouteObject } from \"./router\";\nimport {invariant, normalizePathname, PathMatch, stripBasename, warning} from \"./router\";\nimport {LocaleLanguageKey} from \"./constants\";\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/memory-router\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/components/navigate\n */\nexport function Navigate({ to, replace, state }: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/components/outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface RouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  validator?: (match: RouteMatch) => boolean;\n  icon?: React.ReactNode | null;\n  title?: string | Record<LocaleLanguageKey, string>;\n  name?: string;\n  index?: boolean;\n  path?: string;\n}\n\nexport interface PathRouteProps extends Omit<RouteProps, 'index'> {\n  index?: false;\n}\n\nexport interface LayoutRouteProps {\n  icon?: React.ReactNode | null;\n  validator?: (match: RouteMatch) => boolean;\n  children?: React.ReactNode;\n  title?: string | Record<LocaleLanguageKey, string>;\n  element?: React.ReactNode | null;\n  name?: string;\n}\n\nexport interface IndexRouteProps {\n  icon?: React.ReactNode | null;\n  validator?: (match: RouteMatch) => boolean;\n  element?: React.ReactNode | null;\n  title?: string | Record<LocaleLanguageKey, string>;\n  name?: string;\n  index: true;\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/components/route\n */\nexport function Route(\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/components/routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/create-routes-from-children\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      title: element.props.title,\n      index: element.props.index,\n      validator: element.props.validator,\n      path: element.props.path,\n      name: element.props.name,\n      icon: element.props.icon,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n","/* eslint-disable */\n/**\n * MIT License\n *\n *  Copyright (c) 2021 @quick-toolkit/rc-router-dom YunlongRan<549510622@qq.com>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\n/**\n * 语言枚举\n */\n\nexport enum LocaleLanguage {\n  ar_EG = 'ar_EG', // 阿拉伯语\n  az_AZ = 'az_AZ', // 阿塞拜疆语\n  bg_BG = 'bg_BG', // 保加利亚语\n  bn_BD = 'bn_BD', // 孟加拉语（孟加拉国）\n  by_BY = 'by_BY', // 白俄罗斯语\n  ca_ES = 'ca_ES', // 加泰罗尼亚语\n  cs_CZ = 'cs_CZ', // 捷克语\n  da_DK = 'da_DK', // 丹麦语\n  de_DE = 'de_DE', // 德语\n  el_GR = 'el_GR', // 希腊语\n  en_GB = 'en_GB', // 英语\n  en_US = 'en_US', // 英语（美式）\n  es_ES = 'es_ES', // 西班牙语\n  et_EE = 'et_EE', // 爱沙尼亚语\n  fa_IR = 'fa_IR', // 波斯语\n  fi_FI = 'fi_FI', // 芬兰语\n  fr_BE = 'fr_BE', // 法语（比利时）\n  fr_CA = 'fr_CA', // 法语（加拿大）\n  fr_FR = 'fr_FR', // 法语（法国）\n  ga_IE = 'ga_IE', // 爱尔兰语\n  gl_ES = 'gl_ES', // 加利西亚语（西班牙）\n  he_IL = 'he_IL', // 希伯来语\n  hi_IN = 'hi_IN', // 印地语\n  hr_HR = 'hr_HR', // 克罗地亚语\n  hu_HU = 'hu_HU', // 匈牙利语\n  hy_AM = 'hy_AM', // 亚美尼亚\n  id_ID = 'id_ID', // 印度尼西亚语\n  it_IT = 'it_IT', // 意大利语\n  is_IS = 'is_IS', // 冰岛语\n  ja_JP = 'ja_JP', // 日语\n  ka_GE = 'ka_GE', // 格鲁吉亚语\n  kmr_IQ = 'kmr_IQ', // 北库尔德语\n  kn_IN = 'kn_IN', // 卡纳达语\n  kk_KZ = 'kk_KZ', // 哈萨克语\n  ko_KR = 'ko_KR', // 韩语/朝鲜语\n  lt_LT = 'lt_LT', // 立陶宛语\n  lv_LV = 'lv_LV', // 拉脱维亚语\n  mk_MK = 'mk_MK', // 马其顿语\n  ml_IN = 'ml_IN', // 马拉雅拉姆语\n  mn_MN = 'mn_MN', // 蒙古语\n  ms_MY = 'ms_MY', // 马来语 (马来西亚)\n  nb_NO = 'nb_NO', // 挪威语\n  ne_NP = 'ne_NP', // 尼泊尔语\n  nl_BE = 'nl_BE', // 荷兰语（比利时）\n  nl_NL = 'nl_NL', // 荷兰语\n  pl_PL = 'pl_PL', // 波兰语\n  pt_BR = 'pt_BR', // 葡萄牙语(巴西)\n  pt_PT = 'pt_PT', // 葡萄牙语\n  ro_RO = 'ro_RO', // 罗马尼亚语\n  ru_RU = 'ru_RU', // 俄罗斯语\n  sk_SK = 'sk_SK', // 斯洛伐克语\n  sr_RS = 'sr_RS', // 塞尔维亚语\n  sl_SI = 'sl_SI', // 斯洛文尼亚语\n  sv_SE = 'sv_SE', // 瑞典语\n  ta_IN = 'ta_IN', // 泰米尔语\n  th_TH = 'th_TH', // 泰语\n  tr_TR = 'tr_TR', // 土耳其语\n  ur_PK = 'ur_PK', // 乌尔都语 (巴基斯坦)\n  uk_UA = 'uk_UA', // 乌克兰语\n  vi_VN = 'vi_VN', // 越南语\n  zh_CN = 'zh_CN', // 简体中文\n  zh_HK = 'zh_HK', // 繁体中文（中国香港）\n  zh_TW = 'zh_TW', // 繁体中文（中国台湾）\n}\n\n/**\n * 语言key\n */\nexport type LocaleLanguageKey = keyof typeof LocaleLanguage;\n"],"names":["NavigationContext","React","LocationContext","RouteContext","outlet","matches","routes","current","data","invariant","cond","message","Error","generatePath","path","params","replace","_","key","matchRoutes","locationArg","basename","location","parsePath","pathname","stripBasename","branches","flattenRoutes","sort","a","b","score","length","slice","every","n","i","compareIndexes","routesMeta","map","meta","childrenIndex","rankRouteBranches","matchRouteBranch","parentsMeta","parentPath","forEach","route","index","relativePath","caseSensitive","startsWith","joinPaths","concat","children","push","computeScore","paramRe","isSplat","s","segments","split","initialScore","some","filter","reduce","segment","test","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","Object","assign","iRouteMatch","search","hash","pathnameBase","normalizePathname","validator","pattern","matcher","paramNames","regexpSource","paramName","endsWith","RegExp","undefined","compilePath","captureGroups","memo","splatValue","value","decodeURIComponent","error","safelyDecodeURIComponent","resolvePath","to","fromPathname","toPathname","pop","join","resolvePathname","normalizeSearch","normalizeHash","resolveTo","toArg","routePathnames","locationPathname","from","routePathnameIndex","toSegments","shift","toLowerCase","nextChar","charAt","paths","useHref","useInRouterContext","navigator","useResolvedPath","joinedPathname","getToPathname","endsWithSlash","createHref","useLocation","useNavigationType","navigationType","useMatch","useNavigate","routePathnamesJson","JSON","stringify","activeRef","options","go","parse","state","OutletContext","useOutletContext","useOutlet","context","React.createElement","Provider","useRouteContext","useRouteCurrent","useParams","routeMatch","useRoutes","parentMatches","parentParams","parentPathnameBase","locationFromContext","parsedLocationArg","_renderMatches","reduceRight","element","MemoryRouter","initialEntries","initialIndex","historyRef","createMemoryHistory","history","setState","action","listen","Router","Navigate","navigate","Outlet","props","Route","_props","basenameProp","locationProp","NavigationType","Pop","static","staticProp","navigationContext","trailingPathname","Routes","createRoutesFromChildren","type","apply","title","name","icon","renderMatches","LocaleLanguage"],"mappings":"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"}