{"version":3,"file":"react-router.development.js","sources":["../../../packages/react-router/lib/context.ts","../../../packages/react-router/lib/router.ts","../../../packages/react-router/lib/hooks.tsx","../../../packages/react-router/lib/components.tsx","../../../packages/react-router/lib/constants.ts"],"sourcesContent":["import * as React from \"react\";\nimport type { History, Location } from \"history\";\nimport { Action as NavigationType } from \"history\";\n\nimport type {RouteMatch, RouteObject} from \"./router\";\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport type Navigator = Pick<History, \"go\" | \"push\" | \"replace\" | \"createHref\">;\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nexport const NavigationContext = React.createContext<NavigationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nexport const LocationContext = React.createContext<LocationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\nexport interface RouteContextObject {\n  outlet: React.ReactElement | null;\n  current: RouteObject | null;\n  matches: RouteMatch[];\n  routes: RouteObject[];\n  data: object | null;\n}\n\nexport const RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n  routes: [],\n  current: null,\n  data: null,\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n","import type { Location, Path, To } from \"history\";\nimport { parsePath } from \"history\";\nimport {LocaleLanguageKey} from \"./constants\";\nimport * as React from \"react\";\n\nexport function invariant(cond: any, message: string): asserts cond {\n  if (!cond) throw new Error(message);\n}\n\nexport function warning(cond: any, message: string): void {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\nexport function warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n\ntype ParamParseFailed = { failed: true };\n\ntype ParamParseSegment<Segment extends string> =\n  // Check here if there exists a forward slash in the string.\n  Segment extends `${infer LeftSegment}/${infer RightSegment}`\n    ? // If there is a forward slash, then attempt to parse each side of the\n      // forward slash.\n      ParamParseSegment<LeftSegment> extends infer LeftResult\n      ? ParamParseSegment<RightSegment> extends infer RightResult\n        ? LeftResult extends string\n          ? // If the left side is successfully parsed as a param, then check if\n            // the right side can be successfully parsed as well. If both sides\n            // can be parsed, then the result is a union of the two sides\n            // (read: \"foo\" | \"bar\").\n            RightResult extends string\n            ? LeftResult | RightResult\n            : LeftResult\n          : // If the left side is not successfully parsed as a param, then check\n          // if only the right side can be successfully parse as a param. If it\n          // can, then the result is just right, else it's a failure.\n          RightResult extends string\n          ? RightResult\n          : ParamParseFailed\n        : ParamParseFailed\n      : // If the left side didn't parse into a param, then just check the right\n      // side.\n      ParamParseSegment<RightSegment> extends infer RightResult\n      ? RightResult extends string\n        ? RightResult\n        : ParamParseFailed\n      : ParamParseFailed\n    : // If there's no forward slash, then check if this segment starts with a\n    // colon. If it does, then this is a dynamic segment, so the result is\n    // just the remainder of the string. Otherwise, it's a failure.\n    Segment extends `:${infer Remaining}`\n    ? Remaining\n    : ParamParseFailed;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  ParamParseSegment<Segment> extends string\n    ? ParamParseSegment<Segment>\n    : string;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport interface RouteObject {\n  caseSensitive?: boolean;\n  children?: RouteObject[];\n  icon?: React.ReactNode;\n  element?: React.ReactNode;\n  validator?: (match: RouteMatch) => boolean;\n  title?: string | Record<LocaleLanguageKey, string>;\n  name?: string;\n  index?: boolean;\n  path?: string;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/generate-path\n */\nexport function generatePath(path: string, params: Params = {}): string {\n  return path\n    .replace(/:(\\w+)/g, (_, key) => {\n      invariant(params[key] != null, `Missing \":${key}\" param`);\n      return params[key]!;\n    })\n    .replace(/\\/*\\*$/, (_) =>\n      params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\")\n    );\n}\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface RouteMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObject;\n  /**\n   * transform data\n   */\n  data: object | null;\n  /**\n   * The path query strings\n   */\n  search: string;\n  /**\n   * The path has strings\n   */\n  hash: string;\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-routes\n */\nexport function matchRoutes(\n  routes: RouteObject[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): RouteMatch[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname, location);\n  }\n\n  return matches;\n}\n\ninterface RouteMeta {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObject;\n}\n\ninterface RouteBranch {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta[];\n}\n\nfunction flattenRoutes(\n  routes: RouteObject[],\n  branches: RouteBranch[] = [],\n  parentsMeta: RouteMeta[] = [],\n  parentPath = \"\"\n): RouteBranch[] {\n  routes.forEach((route, index) => {\n    let meta: RouteMeta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({ path, score: computeScore(path, route.index), routesMeta });\n  });\n\n  return branches;\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<ParamKey extends string = string>(\n  branch: RouteBranch,\n  pathname: string,\n  path: Partial<Path>\n): RouteMatch<ParamKey>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: RouteMatch[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n\n    const iRouteMatch: RouteMatch = {\n      params: matchedParams,\n      search: path.search || \"\",\n      hash: path.hash || \"\",\n      data: null,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route: meta.route,\n    };\n\n    if (typeof meta.route.validator === \"function\" && !meta.route.validator(iRouteMatch)) return null;\n\n    matches.push(iRouteMatch);\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end\n      ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n      : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n        // parent routes to matching only their own words and nothing more, e.g. parent\n        // route \"/home\" should not match \"/home2\".\n        // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n        // but do not consume the character in the matched path so they can match against\n        // nested paths.\n        \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string\n): Path {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname;\n\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  let from: string;\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original to value had one.\n  if (\n    toPathname &&\n    toPathname !== \"/\" &&\n    toPathname.endsWith(\"/\") &&\n    !path.pathname.endsWith(\"/\")\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\n\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\nconst normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n","import * as React from \"react\";\nimport type { Location, Path, To } from \"history\";\nimport { Action as NavigationType, parsePath } from \"history\";\n\nimport {LocationContext, NavigationContext, RouteContext, RouteContextObject} from \"./context\";\nimport type {\n  ParamParseKey,\n  Params,\n  PathMatch,\n  PathPattern,\n  RouteMatch,\n  RouteObject,\n} from \"./router\";\nimport {\n  getToPathname,\n  invariant,\n  joinPaths,\n  matchPath,\n  matchRoutes,\n  resolveTo,\n  warning,\n  warningOnce,\n} from \"./router\";\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-href\n */\nexport function useHref(to: To): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to);\n\n  let joinedPathname = pathname;\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname =\n      pathname === \"/\"\n        ? basename + (endsWithSlash ? \"/\" : \"\")\n        : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-in-router-context\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-location\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigation-type\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-match\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-navigate\n */\nexport function useNavigate(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  React.useEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(\n        activeRef.current,\n        `You should call navigate() in a React.useEffect(), not when ` +\n          `your component is first rendered.`\n      );\n\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname\n      );\n\n      if (basename !== \"/\") {\n        path.pathname = joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state\n      );\n    },\n    [basename, navigator, routePathnamesJson, locationPathname]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet-context\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-outlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\nexport function useRouteContext(): RouteContextObject {\n  return React.useContext(RouteContext);\n}\n\nexport function useRouteCurrent(): RouteObject | null {\n  return React.useContext(RouteContext).current\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-params\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\nexport function useResolvedPath(to: To): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    matches.map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname),\n    [to, routePathnamesJson, locationPathname]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/hooks/use-routes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, { pathname: remainingPathname, search: location.search, hash: location.hash });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" does not have an element. ` +\n        `This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  return _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([parentPathnameBase, match.pathname]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([parentPathnameBase, match.pathnameBase]),\n        })\n      ),\n    parentMatches,\n    routes,\n  );\n}\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = [],\n  routes: RouteObject[] = [],\n): React.ReactElement | null {\n  if (matches == null) return null;\n\n  return matches.reduceRight((outlet, match, index) => {\n    return (\n      <RouteContext.Provider\n        children={\n          match.route.element !== undefined ? match.route.element : outlet\n        }\n        value={{\n          outlet,\n          routes,\n          matches: parentMatches.concat(matches.slice(0, index + 1)),\n          current: match.route,\n          data: match.data,\n        }}\n      />\n    );\n  }, null as React.ReactElement | null);\n}\n","import * as React from \"react\";\nimport type { InitialEntry, Location, MemoryHistory, Path, To } from \"history\";\nimport {\n  Action as NavigationType,\n  createMemoryHistory,\n  parsePath,\n} from \"history\";\n\nimport { LocationContext, NavigationContext, Navigator } from \"./context\";\nimport {\n  useInRouterContext,\n  useNavigate,\n  useOutlet,\n  useRoutes,\n  _renderMatches,\n} from \"./hooks\";\nimport type { RouteMatch, RouteObject } from \"./router\";\nimport {invariant, normalizePathname, PathMatch, stripBasename, warning} from \"./router\";\nimport {LocaleLanguageKey} from \"./constants\";\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/memory-router\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({ initialEntries, initialIndex });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n\n  React.useLayoutEffect(() => history.listen(setState), [history]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/components/navigate\n */\nexport function Navigate({ to, replace, state }: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let navigate = useNavigate();\n  React.useEffect(() => {\n    navigate(to, { replace, state });\n  });\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/components/outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface RouteProps {\n  caseSensitive?: boolean;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  validator?: (match: RouteMatch) => boolean;\n  icon?: React.ReactNode | null;\n  title?: string | Record<LocaleLanguageKey, string>;\n  name?: string;\n  index?: boolean;\n  path?: string;\n}\n\nexport interface PathRouteProps extends Omit<RouteProps, 'index'> {\n  index?: false;\n}\n\nexport interface LayoutRouteProps {\n  icon?: React.ReactNode | null;\n  validator?: (match: RouteMatch) => boolean;\n  children?: React.ReactNode;\n  title?: string | Record<LocaleLanguageKey, string>;\n  element?: React.ReactNode | null;\n  name?: string;\n}\n\nexport interface IndexRouteProps {\n  icon?: React.ReactNode | null;\n  validator?: (match: RouteMatch) => boolean;\n  element?: React.ReactNode | null;\n  title?: string | Record<LocaleLanguageKey, string>;\n  name?: string;\n  index: true;\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/components/route\n */\nexport function Route(\n  _props: PathRouteProps | LayoutRouteProps | IndexRouteProps\n): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/routers/router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let location = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key,\n    };\n  }, [basename, pathname, search, hash, state, key]);\n\n  warning(\n    location != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (location == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider\n        children={children}\n        value={{ location, navigationType }}\n      />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/components/routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/utils/create-routes-from-children\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    let route: RouteObject = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      title: element.props.title,\n      index: element.props.index,\n      validator: element.props.validator,\n      path: element.props.path,\n      name: element.props.name,\n      icon: element.props.icon,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n","/* eslint-disable */\n/**\n * MIT License\n *\n *  Copyright (c) 2021 @quick-toolkit/rc-router-dom YunlongRan<549510622@qq.com>\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\n/**\n * 语言枚举\n */\n\nexport enum LocaleLanguage {\n  ar_EG = 'ar_EG', // 阿拉伯语\n  az_AZ = 'az_AZ', // 阿塞拜疆语\n  bg_BG = 'bg_BG', // 保加利亚语\n  bn_BD = 'bn_BD', // 孟加拉语（孟加拉国）\n  by_BY = 'by_BY', // 白俄罗斯语\n  ca_ES = 'ca_ES', // 加泰罗尼亚语\n  cs_CZ = 'cs_CZ', // 捷克语\n  da_DK = 'da_DK', // 丹麦语\n  de_DE = 'de_DE', // 德语\n  el_GR = 'el_GR', // 希腊语\n  en_GB = 'en_GB', // 英语\n  en_US = 'en_US', // 英语（美式）\n  es_ES = 'es_ES', // 西班牙语\n  et_EE = 'et_EE', // 爱沙尼亚语\n  fa_IR = 'fa_IR', // 波斯语\n  fi_FI = 'fi_FI', // 芬兰语\n  fr_BE = 'fr_BE', // 法语（比利时）\n  fr_CA = 'fr_CA', // 法语（加拿大）\n  fr_FR = 'fr_FR', // 法语（法国）\n  ga_IE = 'ga_IE', // 爱尔兰语\n  gl_ES = 'gl_ES', // 加利西亚语（西班牙）\n  he_IL = 'he_IL', // 希伯来语\n  hi_IN = 'hi_IN', // 印地语\n  hr_HR = 'hr_HR', // 克罗地亚语\n  hu_HU = 'hu_HU', // 匈牙利语\n  hy_AM = 'hy_AM', // 亚美尼亚\n  id_ID = 'id_ID', // 印度尼西亚语\n  it_IT = 'it_IT', // 意大利语\n  is_IS = 'is_IS', // 冰岛语\n  ja_JP = 'ja_JP', // 日语\n  ka_GE = 'ka_GE', // 格鲁吉亚语\n  kmr_IQ = 'kmr_IQ', // 北库尔德语\n  kn_IN = 'kn_IN', // 卡纳达语\n  kk_KZ = 'kk_KZ', // 哈萨克语\n  ko_KR = 'ko_KR', // 韩语/朝鲜语\n  lt_LT = 'lt_LT', // 立陶宛语\n  lv_LV = 'lv_LV', // 拉脱维亚语\n  mk_MK = 'mk_MK', // 马其顿语\n  ml_IN = 'ml_IN', // 马拉雅拉姆语\n  mn_MN = 'mn_MN', // 蒙古语\n  ms_MY = 'ms_MY', // 马来语 (马来西亚)\n  nb_NO = 'nb_NO', // 挪威语\n  ne_NP = 'ne_NP', // 尼泊尔语\n  nl_BE = 'nl_BE', // 荷兰语（比利时）\n  nl_NL = 'nl_NL', // 荷兰语\n  pl_PL = 'pl_PL', // 波兰语\n  pt_BR = 'pt_BR', // 葡萄牙语(巴西)\n  pt_PT = 'pt_PT', // 葡萄牙语\n  ro_RO = 'ro_RO', // 罗马尼亚语\n  ru_RU = 'ru_RU', // 俄罗斯语\n  sk_SK = 'sk_SK', // 斯洛伐克语\n  sr_RS = 'sr_RS', // 塞尔维亚语\n  sl_SI = 'sl_SI', // 斯洛文尼亚语\n  sv_SE = 'sv_SE', // 瑞典语\n  ta_IN = 'ta_IN', // 泰米尔语\n  th_TH = 'th_TH', // 泰语\n  tr_TR = 'tr_TR', // 土耳其语\n  ur_PK = 'ur_PK', // 乌尔都语 (巴基斯坦)\n  uk_UA = 'uk_UA', // 乌克兰语\n  vi_VN = 'vi_VN', // 越南语\n  zh_CN = 'zh_CN', // 简体中文\n  zh_HK = 'zh_HK', // 繁体中文（中国香港）\n  zh_TW = 'zh_TW', // 繁体中文（中国台湾）\n}\n\n/**\n * 语言key\n */\nexport type LocaleLanguageKey = keyof typeof LocaleLanguage;\n"],"names":["NavigationContext","React","displayName","LocationContext","RouteContext","outlet","matches","routes","current","data","invariant","cond","message","Error","warning","console","warn","e","alreadyWarned","warningOnce","key","generatePath","path","params","replace","_","matchRoutes","locationArg","basename","location","parsePath","pathname","stripBasename","branches","flattenRoutes","rankRouteBranches","i","length","matchRouteBranch","parentsMeta","parentPath","forEach","route","index","meta","relativePath","caseSensitive","childrenIndex","startsWith","slice","joinPaths","routesMeta","concat","children","push","score","computeScore","sort","a","b","compareIndexes","map","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","segments","split","initialScore","some","filter","reduce","segment","test","siblings","every","n","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","Object","assign","iRouteMatch","search","hash","pathnameBase","normalizePathname","validator","pattern","matcher","paramNames","compilePath","captureGroups","memo","paramName","splatValue","safelyDecodeURIComponent","endsWith","regexpSource","RegExp","undefined","value","decodeURIComponent","error","resolvePath","to","fromPathname","toPathname","resolvePathname","normalizeSearch","normalizeHash","relativeSegments","pop","join","resolveTo","toArg","routePathnames","locationPathname","from","routePathnameIndex","toSegments","shift","getToPathname","toLowerCase","nextChar","charAt","paths","useHref","useInRouterContext","navigator","useResolvedPath","joinedPathname","endsWithSlash","createHref","useLocation","useNavigationType","navigationType","useMatch","useNavigate","routePathnamesJson","JSON","stringify","activeRef","navigate","options","go","parse","state","OutletContext","useOutletContext","useOutlet","context","React.createElement","useRouteContext","useRouteCurrent","useParams","routeMatch","useRoutes","parentMatches","parentParams","parentPathname","parentPathnameBase","parentRoute","locationFromContext","parsedLocationArg","element","_renderMatches","reduceRight","MemoryRouter","initialEntries","initialIndex","historyRef","createMemoryHistory","history","setState","action","listen","Navigate","static","Outlet","props","Route","_props","Router","basenameProp","locationProp","NavigationType","Pop","staticProp","navigationContext","trailingPathname","Routes","createRoutesFromChildren","type","apply","name","title","icon","renderMatches","LocaleLanguage"],"mappings":"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"}